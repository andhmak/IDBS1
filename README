Συμμετέχοντες:
Δημάκης Αντώνιος - sdi1900047
Διαλιάτσης Σπυρίδων - sdi1900051
Μυστριώτης Δημήτριος - sdi1900130

Η hash function που έχουμε χρησιμοποιήσει παίρνει ένα int και επιστρέφει ένα νέο ψευδοτυχαίο θετικό int. Ως εκ τούτου, το πρώτο bit που επιστρέφεται
είναι πάντα 0 (όπως και αυτό της εισόδου εφόσον αν θεωρήσουμε πως έχουμε θετικά id). Άρα έχουμε 8*sizeof(int)-1 bits πληροφορίας. Αγνοούμε δηλαδή
το πρώτο, το οποίο θα είναι πάντα 0, και παίρνουμε τα υπόλοιπα. Άρα με βάθος 1, λαμβάνουμε υπόψιν το δεύτερο bit της hash function, με βάθος 2 το
δεύτερο και το τρίτο, και ούτω καθεξής.

Για λόγους απόδοσης, επειδή στα μηχανήματά μας και στης σχολής υπάρχει μεγάλη καθυστέρηση όταν πλησιάζουμε το θεωρητικό μέγιστο βάθος 8*sizeof(int)-1,
αυτό έχει οριστεί σε 8*sizeof(int)-8.

Έχουμε λάβει υπόψιν κατά τον σχεδιασμό του αλγορίθμου και την περίπτωση που έρχονται πολλές εγγραφές με το ίδιο id, στην οποία περίπτωση δημιουργούνται
αλυσίδες υπερχείλισης αν έχει γεμίσει ένας κάδος και έχουμε φτάσει το μέγιστο βάθος.

Στην υλοποίησή μας κάθε κάδος περιέχεται σε ακριβώς ένα block, έτσι τα δεδομένα διατηρούνται σε έναν πίνακα μετά από τις δευτερεύουσες
πληροφορίες που αποθηκεύονται στην αρχή του block (που είναι το πλήθος εγγραφών στο block, ο δείκτης προς την θέση του επόμενου (για περίπτωση
υπερχείλισης) και το τοπικό βάθος).

Έχει γίνει η παραδοχή πως ως "κάδος" ορίζεται το block που τα περιέχει. Δηλαδή σε περίπτωση υπερχείλισης, ονομάζουμε κάδο τον κάθε έναν "κόμβο"
στην αλυσίδα, και όχι όλη την αλυσίδα μαζί.

Ο ίδιος ο πίνακας κρατάται και αυτός στην μνήμη σε blocks. Κάθε block περιέχει έναν δείκτη προς την θέση του επόμενου και έναν πίνακα με τις θέσεις
των αντιστοίχων κάδων. Έτσι ο πίνακας μπορεί να γίνει αυθαίρετα μεγάλος και δεν περιορίζεται από το μέγεθος του block.

Στην αρχή κάθε αρχείου κρατάμε και ένα block για στατιστικές πληροφορίες, όπως τις συνολικές εγγραφές, τους συνολικούς κάδους και το global depth.

Για κάθε ανοιχτό αρχείο κρατάμε στην μνήμη κάποιες πληροφορίες. Οι βασικότερες είναι ο πίνακας/ευρετήριο, το global depth και το fileDesc που επιστρέφεται
για το συγκεκριμένο αρχείο από το επίπεδο block. Οι μετέπειτα προσβάσεις στον πίνακα για την εύρεση στοιχείων στην δομή μπορεί έτσι να γίνει σε σταθερό
χρόνο με μια πρόσβαση στον πίνακα στην μνήμη, και όχι με διάσχιση των blocks του πίνακα στον δίσκο. Ενώ ένα αρχείο παραμένει ανοιχτό οι αλλαγές στον
πίνακα και η πιθανή μεγέθυνσή του γίνονται μόνο στην μνήμη, ενώ όταν κλείσει γράφονται στον δίσκο.

Για να διατηρήσουμε την εξωτερική συμπεριφορά που ζητά η εκφώνηση, δηλαδή να μπορεί ο χρήστης να ανοίξει πολλές φορές το ίδιο αρχείο και να επιστραφεί
άλλη θέση στον πίνακα ανοιχτών αρχείων, κρατώνται σε αυτόν δύο επιπλέον πράγματα, η "βασική θέση" και το όνομα του αρχείου. Καθε αρχείο είναι ουσιαστικά
ανοιγμένο στην μνήμη μόνο μία φορά (ένα μόνο αντίγραφο του πίνακα στην μνήμη), και οι παραπάνω θέσεις στον πίνακα υπάρχουν για την διευκόλυνση του
χρήστη. Όταν ανοίξει για δεύτερη φορά το ίδιο αρχείο, η νέα θέση στον πίνακα δείχνει προς την "βασική", και από εκεί γίνονται όλες οι προσβάσεις και
οι αλλαγές στα δεδομένα. Το αρχείο κλείνει στο επίπεδο block και ο πίνακας μεταφέρεται στην μνήμη όταν ο χρήστης ζητήσει το κλείσιμο της τελευταίας
αναφοράς το εν λόγω αρχείου στον πίνακα ανοιχτών αρχείων.

Έχουμε υλοποιήσει δύο συναρτήσεις main, την main.c και την error_main.c.
Η πρώτη δοκιμάζει διάφορες λειτουργίες των συναρτήσεων. Αρχικοποιεί δύο αρχεία, το πρώτο με μικρό αρχικό βάθος και το δεύτερο με μεγάλο. Το πρώτο το
ανοίγει μία φορά και το δεύτερο δύο. Στο πρώτο βάζει πολλές εγγραφές με αύξουσα σειρά id και μετά τις τυπώνει (πρώτα μία μόνη της, μετά όλες με αύξουσα
σειρά id, και μετά όλες με την σειρά που δείχνει ο πίνακας (δηλαδή με id==NULL)). Στο δεύτερο βάζει το μέγιστο πλήθος εγγραφών ενός κάδου συν ένα για
να ελεγχθούν οι λίστες υπερχείλισης, και μετά τυπώνει με τον ίδιο τρόπο. Μετά τυπώνονται τα στατιστικά και για τα δύο αρχεία ενώ είναι ανοιχτά, μετά
τα αρχεία κλείνουν, και μετά ξανατυπώνονται τα στατιστικά για τα κλειστά αρχεία.
Στην δεύτερη ο χρήστης επιλέγει μία από τις διάφορες περιπτώσεις που μπορεί να επιστραφεί λάθος από τις συναρτήσεις (στην περίπτωση που δωθεί λάθος
indexDesc ή ανοίξει πάνω από το επιτρεπτό όριο αρχείων), ώστε να ελεγθεί το error handling.

Το makefile που δινόταν για τις bf_main και ht_main έβαζε δεν παρήγαγε .ο αρχεία και έβαζε το εκτελέσιμο στο build. Η μόνη αλλαγή που του κάναμε σε αυτό
είναι να βάζουμε το εκτελέσιμο στο bin, ενώ σε αντίθεση με τις δικές μας main δεν το βάλαμε να παράγει .ο. Με το make <όνομα main>, γίνονται οι
κατάλληλες ενέργειες ώστε να μπορεί να τρέξει η συγκεκριμένη main, ενώ με το make run τρέχει η τελευταία που μεταγλωττίστικε. Me make clean σβήνονται
τα ενδιάμεσα αρχεία, το εκτελέσιμο, καθώς και τα πιθανά αρχεία δεδομένων που έχουν παραχθεί.